Vincent Broda
CS462
Assignment 2 Report

###################################
myocean.c
Argument/Demonstration
To prove my program works, I used the following, (steps could be anything here, depending on how much you want to see)
xMax = 6
yMax = 6
steps = _
Grid:
1 1  1  1  1  1
1 10 10 10 10 1
1 10 10 10 10 1
1 10 10 10 10 1
1 10 10 10 10 1
1 1  1  1  1  1
This follows the 2^n +2 rule that the size should follow, as well as be enough steps to come to realy average out to what the boarder is.
This is also possible since every boarder is the name number.

The first thing I wanted to check is that the red black subsets where working correctly and that black went on odd steps and red on even.
This was done assuming the steps are indexed on zero,which i will do with everyting going forward, so red would cells should update first.
The subsets shold look like:
B R B R B R
R B R B R B
B R B R B R
R B R B R B
B R B R B R
R B R B R B

with indexes of:
00 01 02 03 04 05 
10 11 12 13 14 15 
20 21 22 23 24 25 
30 31 32 33 34 35 
40 41 42 43 44 45 
50 51 52 53 54 55 

therefore, on our initial step, we will expect the non boarder black nodes to change in the first set, and then the red to change on the next, in a repeating pattern until the steps have concluded.

Since our grid here is simple, we can do the caclulations by hand to double check the beggining caclulations for the temperatures.
Our first point, not at a location border will have a new temperature of (tmp_02 + tmp_11 + tmp_12 + tmp_13 + tmp_22) / 5
This would be (1 + 10 + 10 + 10 + 10) / 5 = 8.2
We can continue doing this for the rest of the points. It also does not really matter what order we do this insince a cell cannot affect a cell of the same color within the same step.
We will expect a new grid of:
1 1   1   1   1   1
1 10  8.2 10  6.4 1
1 8.2 10  10  10  1
1 10  10  10  8.2 1
1 6.4 10  8.2 10  1
1 1   1   1   1   1

We will now check out the next step for the black cells. We will use similar logic to above, with the only diffrences being we will use the resulting grid from the previous step, and we will be only changing black cells this time. When we do this we should expect a grid of:
1  1     1     1     1     1
1  5.68  8.2   7.12  6.4   1
1  8.2   9.28  10    7.12  1
1  7.12  10    9.28  8.2   1
1  6.4   7.12  8.2   5.68  1
1  1     1     1     1     1

We can directly test this by printing out our programs output at these two steps, and we get:
Step 0:
1.000 1.000 1.000 1.000 1.000 1.000 
1.000 10.000 8.200 10.000 6.400 1.000 
1.000 8.200 10.000 10.000 10.000 1.000 
1.000 10.000 10.000 10.000 8.200 1.000 
1.000 6.400 10.000 8.200 10.000 1.000 
1.000 1.000 1.000 1.000 1.000 1.000 


Step 1:
1.000 1.000 1.000 1.000 1.000 1.000 
1.000 5.680 8.200 7.120 6.400 1.000 
1.000 8.200 9.280 10.000 7.120 1.000 
1.000 7.120 10.000 9.280 8.200 1.000 
1.000 6.400 7.120 8.200 5.680 1.000 
1.000 1.000 1.000 1.000 1.000 1.000 
which besides going one decimal place further, gives us the same answer.

We could keep doing this for as many steps as we want, however, since the boarder nodes are all the same and remain constant, we can expect that given enought time, the averages will converge to that constant number. In this case we should expect every changing node to have its temperature keep falling to 1 until all of them have reached this number. The technicalities of this might be weird due to floating point numbers, but we should expect something like:
1 1 1 1 1 1
1 1 1 1 1 1
1 1 1 1 1 1
1 1 1 1 1 1
1 1 1 1 1 1
1 1 1 1 1 1

to happen after a long enough time. This is an approximation since technically most of those 1's are really a number slightly bigger than 1, but this diffrence is so small I do not think it matters. It will also not take that long to occur for a grid this small, so if we look at step 77, we wil see
Step: 77
1.000 1.000 1.000 1.000 1.000 1.000 
1.000 1.000 1.000 1.000 1.000 1.000 
1.000 1.000 1.000 1.000 1.000 1.000 
1.000 1.000 1.000 1.000 1.000 1.000 
1.000 1.000 1.000 1.000 1.000 1.000 
1.000 1.000 1.000 1.000 1.000 1.000 

It happens in part to me printing out only 3 decimal points of precision, but we see that the effect of symetry we expected has occured.

Time Analysis
I ran the following bach script:
#!/bin/bash

# Number of runs
num_runs=1000

total_time=0

# Loop for the specified number of runs
for ((i = 1; i <= num_runs; i++)); do
    # Run myocean with input file and capture the TIME value
    time_output=$(./myocean < myocean.in | grep "TIME" | awk '{print $2}')
    
    # Check if the output contains TIME value
    if [[ -n "$time_output" ]]; then
        # Add the TIME value to the total_time
        total_time=$(echo "$total_time + $time_output" | bc -l)
    fi
done

# Calculate the average TIME value
average_time=$(echo "$total_time / $num_runs" | bc -l)

# Print the average TIME value
echo "Average TIME: $average_time"

which takes the average time given by myocean.c when ran 1000 times with the larger file. This time comes from putting omp_get_wtime() after the grid is set up, so it is only timing the steps, where the averages are calculated. After running this, I got: Average TIME: .05073056000000000000. 

############################################
myocean-omp.c
